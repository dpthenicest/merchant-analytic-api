import uuid
from datetime import datetime
from decimal import Decimal, InvalidOperation
from typing import Literal, Optional
from pydantic import BaseModel, ConfigDict, Field, field_validator


class MerchantEventCreate(BaseModel):
    # event_id is REQUIRED - UUID from CSV
    event_id: uuid.UUID

    # merchant_id is OPTIONAL - format: MRC-XXXXXX (when provided)
    merchant_id: Optional[str] = Field(default=None)

    # event_timestamp - ISO 8601 format, optional
    event_timestamp: Optional[datetime] = Field(default=None)

    # product - Product category (optional - empty becomes None)
    product: Optional[Literal[
        "POS", "AIRTIME", "BILLS", "CARD_PAYMENT",
        "SAVINGS", "MONIEBOOK", "KYC"
    ]] = Field(default=None)

    # event_type - Type of activity (optional)
    event_type: Optional[str] = Field(default=None)

    # amount - Transaction amount in NGN (0 for non-monetary, optional)
    amount: Optional[Decimal] = Field(default=None)

    # status - One of: SUCCESS, FAILED, PENDING (optional)
    status: Optional[Literal["SUCCESS", "FAILED",
                             "PENDING"]] = Field(default=None)

    # channel - One of: POS, APP, USSD, WEB, OFFLINE (optional)
    channel: Optional[Literal["POS", "APP", "USSD",
                              "WEB", "OFFLINE"]] = Field(default=None)

    # region - Merchant's operating region (optional)
    region: Optional[str] = Field(default=None)

    # merchant_tier - KYC tier: STARTER, VERIFIED, PREMIUM (optional)
    merchant_tier: Optional[Literal["STARTER",
                                    "VERIFIED", "PREMIUM"]] = Field(default=None)

    @field_validator('merchant_id', mode='before')
    @classmethod
    def validate_merchant_id(cls, v):
        """Validate merchant_id format, return None if invalid"""
        if not v or (isinstance(v, str) and not v.strip()):
            return None
        if isinstance(v, str):
            v = v.strip()
            # Check if it matches the required format
            if not __import__('re').match(r"^MRC-[A-Z0-9]{6}$", v):
                return None
            return v
        return None

    @field_validator('event_type', 'region', mode='before')
    @classmethod
    def convert_string_empty_to_none(cls, v):
        """Convert empty strings to None for string fields"""
        if isinstance(v, str) and not v.strip():
            return None
        return v.strip() if isinstance(v, str) else v

    # @field_validator('event_timestamp', mode='before')
    # @classmethod
    # def parse_datetime(cls, v):
    #     """Handle datetime parsing to ISO 8601 format (YYYY-MM-DDTHH:MM:SS)"""
    #     if v is None or (isinstance(v, str) and not v.strip()):
    #         return None
    #     try:
    #         if isinstance(v, str):
    #             # Try parsing as ISO 8601 format first
    #             dt = datetime.fromisoformat(v)
    #             return dt.isoformat()
    #         elif isinstance(v, datetime):
    #             return v.isoformat()
    #         return v
    #     except (ValueError, TypeError):
    #         return None

    @field_validator('event_timestamp', mode='before')
    @classmethod
    def parse_datetime(cls, v):
        """
        Parses various string formats into a timezone-aware datetime object.
        Ensures that '2024-01-04 21:31:37+01' is correctly interpreted.
        """
        if v is None or (isinstance(v, str) and not v.strip()):
            return None

        try:
            if isinstance(v, str):
                # 1. Clean the string
                clean_v = v.strip().replace(" ", "T")

                # 2. Parse into a datetime object
                # fromisoformat handles +01, +01:00, and Z correctly
                return datetime.fromisoformat(clean_v)

            elif isinstance(v, datetime):
                return v

            return v
        except (ValueError, TypeError):
            # In a real hackathon, you might want to log this error
            return None

    @field_validator('amount', mode='before')
    @classmethod
    def parse_amount(cls, v):
        """Handle decimal parsing, return None if invalid"""
        if v is None or (isinstance(v, str) and not v.strip()):
            return None
        try:
            if isinstance(v, str):
                amount = Decimal(v.strip())
                # Ensure amount is not negative
                if amount < 0:
                    return None
                return amount
            return v
        except (InvalidOperation, ValueError, TypeError):
            return None


class MerchantEventResponse(MerchantEventCreate):
    model_config = ConfigDict(from_attributes=True)

    # The ID is usually generated by the DB and returned in the response
    event_id: uuid.UUID
